---
layout:     post
title:      "Дуже легке введення в програмування комп'ютерної графіки :)"
date:       2017-04-12 22:00:00
author:     "Malkevych Roman - rmalkevy"
---

Ключові слова: 3D, ракурс, стереоскопічний зір, походження, координати, координатна система, 3D-сцена, топологія, модель, сітка, полігон, вершини, ребро, перспективна проекція, перегляд усіченого, перспектива розподіл, подібні трикутники, екранний простір, нормалізація.

## Зрозумій як це працює!

Якщо ви тут, це, ймовірно, тому, що ви хочете навчитися комп'ютерної графіки. Кожен читач може мати різні причини бути тут, але ми всі рухомі тим же бажанням: зрозуміти, як це працює! Scratchapixel був створений, щоб відповісти на це конкретне питання. Тут ви дізнаєтеся, як це працює, і дізнатеся методи, які використовуються для створення CGI (computer generated imaginary), від найпростіших і важливих методів, до більш складних і менш поширених. Можливо, ви любите відеоігри, і ви хотіли б знати, як це працює, як вони зроблені. Може бути, що ви бачили фільм Pixar і цікаво, яка магія за ним. Якщо ви в школі, університеті, вже працюєте в цій галузі (або у відставці), ніколи не пізно, щоб бути зацікавленим в цих темах, щоб вивчити або поліпшити свої знання, і ми завжди потрібуємо такого ресурсу, як Scratchapixel, щоб знайти відповіді на ці питання. Ось чому ми тут.
Scratchapixel доступний для всіх. Це уроки для всіх рівнів. Звичайно, це вимагає мінімуму знань в галузі програмування. У той час як ми плануємо написати короткий вступний урок з програмування в найближчому майбутньому, місія Scratchapixel є не про навчання програмування. Проте, в той час як ви будете дізнаватися про реалізацію різних методів, використовуваних для створення CGI, ви також, ймовірно, поліпшите свої навички програмування в процесі і вивчите кілька трюків програмування. Чи вважаєте ви себе новачком або експертом в галузі програмування, ви знайдете тут всі види уроків, адаптованих до вашого рівня. Почніть з простого, з базових програм і прогресуйте звідти. Щодо складності, якщо ви подивитеся на список уроків для кожної категорії, ви побачите математичну етикетку, за якою слідує ряд плюсів (знак «+»). Чим більше плюсів, тим важчі уроки з точки зору математики (три плюси максимум).

## Легке введення в програмування комп'ютерної графіки

Ви хочете дізнатися про комп'ютерну графіку. Перше, що вам потрібно знати, що це таке? У другому уроці цього розділу, ви можете знайти визначення комп'ютерної графіки, а також дізнатися про те, як це взагалі працює. Можливо, ви чули про такі терміни, як моделювання, геометрія, анімація, 3D, 2D, цифрові зображення, 3D-перегляд, рендеринг в режимі реального часу, композитінг, але ви не впевнені в тому, що вони означають, і що більш важливо, як вони співвідносяться один з одним. Другий урок цього розділу відповість на ці питання. Звідси, ви повинні дізнатись трохи про програмування CG та отримаєте загальне уявлення про CG і різні інструменти і процеси, що беруть участь в створенні CGI.

Що далі? Наш світ принципово тривимірний. В крайньому випадку, наскільки ми можемо відчути його з нашими органами чуття. Деякі люди хотіли б додати вимір часу. Час грає важливу роль в CGI, але ми повернемося до цього пізніше. Об'єкти з реального світу, тобто тривимірні (three-dimensional). Це факт, ми думаємо, що ми всі можемо погодитися, без ніяких доведень. Однак, що цікаво, це бачення (vision), яким є один з органів чуття, за допомогою якого цей тривимірний світ може бути побачено, принципово двовимірний процес. Ми могли б сказати, що, можливо, образ, створений в нашій свідомості є безрозмірним (ми ще не дуже добре розуміємо як зображення «з'являються» в нашому мозку), але коли ми говоримо про зображення, як правило, це означає для нас плоска поверхня, на якої розмірність об'єктів було скорочено з трьох до двох вимірів (поверхні полотна або поверхні екрану). Єдина причина, чому це зображення на полотні насправді виглядає таким точним для нашого мозку, тому що об'єкти стаю все меншими, чим далі від вас вони знаходяться, ефект, що називається ракурсом (foreshortening). Якщо ви не впевнені в цьому, думайте про зображення як про дзеркальне відображення. Поверхня дзеркала ідеально рівна, і тим не менш, ми не можемо знайти різницю дивлячись на зображення сцени, відбитого від дзеркала і споглядання прямо на сцені: ти не вловлюєш відображення, тільки об'єкт. Це тому, що у нас є два ока, за допомогою яких ми дійсно можемо отримати почуття бачити речі в 3D, те, що ми називаємо стереоскопічний зір (stereoscopic vision). Кожне око дивиться на одну і тій же сцену з трохи іншим кутом, і мозок може використовувати ці два зображення однієї і тієї ж сцени, щоб наблизити відстань і положення об'єктів в 3D-просторі по відношенню один до одного. Однак стереоскопічний зір таким чином обмежений, що ми не можемо виміряти відстань до об'єктів або їх розмір дуже точно (що комп'ютери можуть зробити). Людський зір досить складний і вражаючий результат еволюції, але тим не менш, трюк, і його можна легко обдурити (багато фокусів засновані на цьому). В якійсь мірі, комп'ютерна графіка є засобом, за допомогою якого ми можемо створити образи штучних світів і представити їх в мозок (через бачення), як переживання реальності (те, що ми називаємо фото-реалізм), так само, як дзеркальне відображення. Ця тема є досить поширеним явищем в науковій фантастиці, але технологія не далекі від того, щоб зробити це можливим.
```
Це насправді важливо, щоб сказати тут, що в той час як ми, здається, більше зосереджені на процесі створення цих зображень, процес, який ми називаємо рендеринг, комп'ютерна графіка не тільки про створення зображення, а й про розробку методів для моделювання таких речей, як рух рідини, рух м'яких і твердих тіл, знаходження способів анімації об'єктів і аватарів таким чином, щоб їх рух і всі ефекти, що виникають в результаті цього руху точно змоделювались (наприклад, коли ви гуляєте, форма ваших м'язів змінюються і в загальному форма вашого тіла є результатом цих м'язових деформацій), щоб створити реалістичний аватар вам потрібно знайти способи моделювання цих ефектів. Ми також дізнаємося про ці методи на Scratchapixel.
```
Що ми дізналися досі? Те, що світ є тривимірним, що ми дивимося на нього як на двовимірний, і що, якщо ви можете повторити форму і зовнішній вигляд об'єктів, мозок не може відрізнити різницю дивлячись на ці об'єкти безпосередньо, і дивлячись на зображення цих об'єктів. Комп'ютерна графіка не обмежується створенням фотореалістичних зображень, але в той час простіше створити не фотореалістичні зображення, ніж створення абсолютно фотореалістичних, мета комп'ютерної графіки справжній реалізм (як багато в шляху речі рухатися, ніж вони з'являються). 
Все, що нам потрібно зробити зараз, це дізнатися, які правила для створення такого фотореалістичного зображення є, і це те, що ви також дізнаєтеся тут на Scratchapixel.

## Опис предметів, що становлять віртуальний світ

Різниця між художником, який насправді малює реальну картину (якщо предмет картини не виходить за межі його / її уяви), і нами при створенні зображення за допомогою комп'ютера, в тому, що ми насправді повинні спочатку якось описати форму (і зовнішній вигляд) об'єктів, що становлять сцену, якщо ми хочемо зарендерити зображення на комп'ютері.
![Image](https://rmalkevy.github.io/img/1_coordinate-system.png)
Figure 1: a 2D Cartesian coordinative systems defined by its two axis (x and y) and the origin. This coordinate system can be used as a reference to define the position or coordinates of points within the plane.

Одне з найпростішого і найбільш важливого поняття, що ми вивчили в школі є ідея простору, в якому можуть бути визначені точки. Положення точки, як правило, визначається по відношенню до початку координат. На лінійці, це, як правило, місце позначене номером нуль. Якщо ми використовуємо дві лінійки, одна перпендикулярна до іншої, ми можемо визначити положення точок в двох вимірах. Додайте третю лінійку, перпендикулярно до перших двох, і ви можете визначити положення точок в трьох вимірах. Фактичні числа, що представляють положення точки по відношенню до однієї з трьох лінійок називаються координатами точок.

![Image](https://rmalkevy.github.io/img/2_box1.png)
Figure 2: a box can be described by specifying the coordinates of its eight corners in a Cartesian coordinate system.

Ми всі знайомі з концепцією координат, щоб відзначити де ми були відносно деякої опорної точки або лінії (наприклад, Грінвічський меридіан). Тепер ми можемо визначити точки в трьох вимірах. Давайте уявимо, що ви тільки що купили комп'ютер. Цей комп'ютер, ймовірно, приїхав в коробці, і ця коробка має вісім кутів (вибачте, що констатую очевидне). Одним із способів опису цієї коробки, є вимірювання відстані від цих 8 кутів по відношенню до одного з кутів. Цей кут діє як початок нашої системи координат і, очевидно, відстань цього опорного кута по відношенню до самого себе буде у всіх вимірах 0. Однак відстань від опорного кута до семи інших кутів, буде відрізнятися від 0. Давайте зобразимо, що наша коробка має наступні розміри:

```Markdown
corner 1: ( 0, 0,  0) 
corner 2: (12, 0,  0) 
corner 3: (12, 8,  0) 
corner 4: ( 0, 8,  0) 
corner 5: ( 0, 0, 10) 
corner 6: (12, 0, 10) 
corner 7: (12, 8, 10) 
corner 8: ( 0, 8, 10)
```
![Image](https://rmalkevy.github.io/img/3_box2.png)
Figure 3: a box can be described by specifying the coordinates of its eight corners in a Cartesian coordinate system.

Перше число представляє ширину, друге число - висоту, і третє число - глибину. Кут 1, як ви можете бачити, є початком, з якого всі кути були виміряні. Все, що вам потрібно зробити тут, це якось написати програму, в якій буде визначено концепцію тривимірної точки, і використовувати її для зберігання координат восьми точок, які ви тільки що виміряли. На C / C++, така програма могла б виглядати наступним чином:

```Markdown
typedef float Point[3]; 
int main() 
{ 
    Point corners[8] = { 
        { 0, 0,  0}, 
        {12, 0,  0}, 
        {12, 8,  0}, 
        { 0, 8,  0}, 
        { 0, 0, 10}, 
        {12, 0, 10}, 
        {12, 8, 10}, 
        { 0, 8, 10}, 
    }; 
 
    return 0; 
} 
```

Як і в будь-якій мові, завжди є різні способи зробити те ж саме. Ця програма показує один можливий шлях в C / C ++ для визначення поняття точки (лінія 1) і зберігання кутів коробки в пам'яті (в даному прикладі, як масив з восьми точок).

Ви якимось чином створили свою першу програму 3D. Вона ще не виробляє зображення, але ви вже можете зберігати опис 3D-об'єкта в пам'яті. У CG колекція з цих об'єктів називається сцена (сцена також включає в себе поняття камери і світла, але ми будемо говорити про це іншим разом). Як було зазначено раніше, нам не вистачає двох дуже важливих речей, щоб зробити процес дійсно повним і цікавим. По-перше, щоб насправді відобразити коробку в пам'яті комп'ютера, в ідеалі, ми також потребуємо системи, яка визначає, як ці вісім точок з'єднані одна з одною, щоб відобразити грані (faces) коробки. У CG, це називається топологія (topology) об'єкта (об'єкт також називається моделлю (model)). Ми будемо говорити про це в розділі Геометрія і основи 3D рендера (в уроці по візуалізації трикутників і полігональних сіток). Топологія відноситься до того, як точки, які ми зазвичай називаємо вершини (vertices) з'єднані одна з одною з утворенням граней (або плоских поверхонь). Ці грані також називаються багатокутники (полігони). Коробка буде зроблена з шести граней або шести полігонів і набір багатокутників утворює те, що ми називаємо полігональною сіткою (polygonal mesh) або просто сітка. Друге, що нам не вистачає, це система для створення образу цього блоку. Це вимагає, щоб фактично проектувати кути коробки на уявному полотні, процес який ми називаємо перспективна проекція.

## Створення зображення цього віртуального світу

![Image](https://rmalkevy.github.io/img/4_frustum4.png)
Figure 4: if you connect the corners of the canvas to the eye which by default is aligned with our Cartesian coordinate system, and extend the lines further away into the scene, you get some sort of pyramid which we call a viewing frustum. Any object contained within the frustum (or overlapping it) is visible and will show up on the image.

Процес проектування 3D точки поверхні полотна, насправді включає в себе спеціальну матрицю, яку ще називають перспективна матриця (не хвилюйтеся, якщо ви не знаєте, що таке матриця). Використання матриці для проектування точки не є абсолютно необхідним, але робить речі набагато простішими. Тим не менш, вам насправді не потрібні математика і матриці, щоб з'ясувати, як це працює. Ви можете побачити зображення, або полотно, як якиусь плоску поверхню, яка розташована на деякій відстані від очей. Пропускаючи чотири лінії, починаючи від очей до кожного з чотирьох кутів полотна і продовжуючи ці лінії далі в світ (наскільки ви можете бачити). Ви отримуєте піраміду, яку ми називаємо viewing frustum (але не усічену (frustrum)).
Viewing frustum визначає якийсь об'єм в 3D просторі і полотно є простою площиною, яка перерізає цей простір перпендикулярно до лінії очей. Помістіть коробку перед полотном. Далі, проведіть лінію від кожного кута коробки до ока і відзначте точку, де лінія перетинає полотно. Знайдіть на полотні точки, що відповідають кожному з дванадцяти ребер коробки, і проведіть лінію між цими точками. Що ти бачиш? Зображення коробки.
![Image](https://rmalkevy.github.io/img/5_box-setup1.png)
Figure 5: the box is move in front of our camera setup. The coordinates of the box corners are expressed with respect to this Cartesian coordinate system.

Три лінійки, які використовувались для вимірювання координат кутів коробки, ми називаємо системою координат. Це система, в якій точки можуть бути виміряні. Координати всіх точок належать до цієї системи координат. Зверніть увагу, що координата може бути або позитивною або негативною (або нульовою) в залежності від того, чи вона розташована праворуч або ліворуч від початку лінійки (значення 0). У CG, цю систему координат часто називають світовою системою координат, і точка (0,0,0), початок системи координат.
![Image](https://rmalkevy.github.io/img/6_box-setup2.png)
Figure 6: connecting the box corners to the eye.

Давайте перейдемо до вершини піраміди на початку координат і лінії погляду (напрямок погляду) уздовж негативної осі (рисунок 3). Багато графічних додатків використовують цю конфігурацію, як за замовчуванням їх «систему перегляду». Майте на увазі, що вершина піраміди насправді точка, з якої ми будемо дивитися на сцену. Давайте також перемістимо полотно на одну одиницю від нуля. Нарешті, давайте перемістимо вікно на деяку відстань від початку координат, так що вона повністю знаходитиметься в межах об'єму піраміди. Оскільки коробка знаходиться в новому положенні (ми перемістили її), координати восьми кутів змінилися, і ми повинні виміряти їх знову.
![Image](https://rmalkevy.github.io/img/7_box-setup3.png)
Figure 7: the intersection points between these lines and the canvas are the projection of the box corners onto the canvas. By connecting these points to each other, an wireframe image of the box is created.

Зверніть увагу, так як коробка на лівій стороні від початку лінійки, від якого ми вимірюємо глибину об'єкта, всі координати глибини, які також називаються Z-координати будуть негативними. Чотири з кутів також нижче точки відліку, що використовується для вимірювання висоти об'єкта, і буде мати негативну висоту або у-координату. Нарешті, чотири з кутів будуть зліва від початку лінійки вимірюваної ширини об'єкта: їх ширина, або х-координата також буде негативною. Нові координати кутів короба такі:
```Markdown
corner 1: ( 1, -1, -5) 
corner 2: ( 1, -1, -3) 
corner 3: ( 1,  1, -5) 
corner 4: ( 1,  1, -3) 
corner 5: (-1, -1, -5) 
corner 6: (-1, -1, -3) 
corner 7: (-1,  1, -5) 
corner 8: (-1,  1, -3)
```
![Image](https://rmalkevy.github.io/img/8_box-setup4.png)
Figure 8: the coordinates of the point P', the projection of P on the canvas can be computed using simple geometry. The rectangle ABC and AB'C' are said to be similar.

Давайте подивимося на нашу інсталяцію з боку і проведемо лінію від одного з кутів до координат (точки огляду). Ми можемо визначити два трикутника: ABC і AB'C. Як ви можете бачити, що ці два трикутника мають однаковий початок (A). Вони є також такими собі копіями один одного, в тому сенсі, що кут, утворений ребрами АВ і АС є таким же, як кут, утворений ребрами AB' і AC'. Такі трикутники називаються подібними. Подібні трикутники мають цікаву властивість: співвідношення між їх суміжними і протилежними сторонами однакові. Іншими словами:

```Markdown
BC / AB = B'C' / AB'.
```
Оскільки полотно на 1 одиницю від початку координат, ми знаємо, що AB дорівнює 1. Ми також знаємо позицію B і C, які є z (глибина) і у координати (висота) по відношенню до кута. Якщо підставити ці числа в наведеному вище рівнянні, отримаємо:

```Markdown
P.y / P.z = P'.y / 1.
```
Як ви можете бачити, проекція з кута в у-координаті на полотні, це не більше, ніж у-координата, розділена на глибину (Z-координата). Це, ймовірно, одне з найпростіших і найбільш фундаментальних відношень в галузі комп'ютерної графіки, відомої як z або перспективне ділення. Точно такий же принцип застосуємо і до х координат. Спроектована точка х координати (х ') є x координатою поділеною на z координату.

Зауважу, проте, що, оскільки z-координата Р негативна в нашому прикладі (ми пояснимо, чому це завжди буває на уроці з основ 3D рендерингу, присвяченого перспективній проекції матриці), коли координата х позитивна , х-координата проектованої точки стане негативною (аналогічно, якщо Px негативна, P'.x стане позитивною. Та ж ситуація відбувається з у-координатою). В результаті зображення 3D об'єкта відбивається як по вертикалі, так і по горизонталі, що не є ефектом, який ми хочемо. Таким чином, щоб уникнути цієї проблеми, ми розділимо P.x і P.y координати на P.z зі знаком мінус; це зберігає знак в координатах х і у. Ми нарешті отримаємо:

```Markdown
P'.x = P.x / -P.z.

P'.y = P.y / -P.z.
```
Тепер у нас є метод, щоб обчислити фактичні позиції кутів, як вони з'являються на поверхні полотна. Це двовимірні координати точок, які проектується на полотні. Давайте оновимо нашу програму для обчислення цих координат:

```Markdown
typedef float Point[3]; 
int main() 
{ 
    Point corners[8] = { 
         { 1, -1, -5}, 
         { 1, -1, -3}, 
         { 1,  1, -5}, 
         { 1,  1, -3}, 
         {-1, -1, -5}, 
         {-1, -1, -3}, 
         {-1,  1, -5}, 
         {-1,  1, -3} 
    }; 
 
    for (int i = 0; i < 8; ++i) { 
        // divide the x and y coordinates by the z coordinate to 
        // project the point on the canvas
        float x_proj = corners[i][0] / -corners[i][2]; 
        float y_proj = corners[i][1] / -corners[i][2]; 
        printf("projected corner: %d x:%f y:%f\n", i, x_proj, y_proj); 
    } 
 
    return 0; 
} 
```
Розмір самого полотна також є довільним. Воно також може бути квадратної або прямокутної форми. У нашому прикладі, ми зробили його в дві одиниці шириною в обох напрямках, що означає, що х і у координати будь-яких точок, що лежать на полотні, містяться в діапазоні від -1 до 1 (зображення 9).
![Image](https://rmalkevy.github.io/img/9_frustum.png)
Figure 9: in this example, the canvas is 2 units along the x-axis and 2 units along the y-axis. You can change the dimension of the canvas if you wish. By making it bigger or smaller you will see more or less of the scene.

Питання: що станеться, якщо яка-небудь з проектованих координат точки не в цьому діапазоні, якщо, наприклад, х дорівнює -1.1? Точка буде просто не видною, вона лежить поза межами полотна.

На даний момент ми говоримо, що прогнозована координата точки в просторі екрану (screen space)(простір екрану, де екран і полотно в цьому контексті синоніми). Але ними не так легко маніпулювати, тому що вони можуть бути або негативними або позитивними, і ми не знаємо, як вони насправді відносяться по відношенню до, наприклад, розміру екрану вашого комп'ютера (якщо ми хочемо відобразити ці точки на екрані). З цієї причини ми спочатку нормалізувати їх, що просто означає, що ми перетворюємо їх з будь-якого діапазону в якому вони спочатку були, в діапазон [0,1]. У нашому випадку, так як нам потрібно відобразити координати від -1,1 до 0,1, ми можемо просто написати:

```Markdown
float x_proj_remap = (1 + x_proj) / 2; 
float y_proj_remap = (1 + y_proj) / 2; 
```
Координати, спроектовані в точках, не в діапазоні 0,1. Такі координати називаються визначені в NDC просторі, що означає нормовані реальні координати (Normalized Device Coordinates). Це зручно, тому що незалежно від початкового розміру полотна (або екрана), який може відрізнятися в залежності від налаштувань, які ви використовували, тепер ми маємо всі точки координат, визначені в загальному просторі. Термін нормалізація є дуже поширеним явищем. Це означає, що ви якимось чином перепризначаєте значення з будь-якого діапазону в якому вони були спочатку, в діапазон [0,1]. Нарешті, ми зазвичай вважаємо за краще, щоб визначити координати точки відносно розмірів кінцевого зображення, які, як ви знаєте чи ні, визначаються в пікселях. Цифрове зображення є нічим іншим, як двовимірний масив пікселів (як ваш екран комп'ютера).

Ти знаєш яким є розширення твого екрану в пікселях?

512x512 зображення являє собою цифрове зображення, що має 512 рядків по 512 пікселів, ви вважаєте за краще бачити його іншим чином, 512 стовпців по 512 вертикально орієнтованих пікселів. Так як наші координати вже нормалізовані, все, що нам потрібно зробити, щоб виразити їх в пікселях, це помножити ці NDC координати на розмір зображення (512). Так як наше полотно є квадратом, ми будемо також використовувати квадратне зображення:

```Markdown
#include <cstdlib> 
#include <cstdio> 
 
typedef float Point[3]; 
 
int main() 
{ 
    Point corners[8] = { 
         { 1, -1, -5}, 
         { 1, -1, -3}, 
         { 1,  1, -5}, 
         { 1,  1, -3}, 
         {-1, -1, -5}, 
         {-1, -1, -3}, 
         {-1,  1, -5}, 
         {-1,  1, -3} 
    }; 
const unsigned int image_width = 512, image_height = 512; 
 
    for (int i = 0; i < 8; ++i) { 
        // divide the x and y coordinates by the z coordinate to 
        // project the point on the canvas
        float x_proj = corners[i][0] / -corners[i][2]; 
        float y_proj = corners[i][1] / -corners[i][2]; 
        float x_proj_remap = (1 + x_proj) / 2; 
        float y_proj_remap = (1 + y_proj) / 2; 
        float x_proj_pix = x_proj_remap * image_width; 
        float y_proj_pix = y_proj_remap * image_height; 
        printf("corner: %d x:%f y:%f\n", i, x_proj_pix, y_proj_pix); 
    } 
 
    return 0; 
} 
```
Отримані координати визначаються в растровому просторі (XX століття, що це растр значить, поясніть, будь ласка). Наша програма як і раніше обмежена, оскільки вона не створює зображення коробки, але якщо ви скомпілювати і запустити її за допомогою наступних команд (копіювати / вставити код в файл і зберегти його як box.cpp):

```Markdown
c++ box.cpp 
./a.out 
corner: 0 x:307.200012 y:204.800003 
corner: 1 x:341.333344 y:170.666656 
corner: 2 x:307.200012 y:307.200012 
corner: 3 x:341.333344 y:341.333344 
corner: 4 x:204.800003 y:204.800003 
corner: 5 x:170.666656 y:170.666656 
corner: 6 x:204.800003 y:307.200012 
corner: 7 x:170.666656 y:341.333344 
```
Ви можете використовувати програму для малювання для створення зображення (встановіть його розмір до 512х512), а також додайте точки в піксельних координатах, які обчислені вашою програмою. Потім з'єднайте точки, щоб сформувати краЇ коробки, і ви отримаєте реальне зображення коробки (як показано у відео нижче). Піксельні координати є цілими числами, так що вам потрібно буде округляти числа, задані програмою.

## Video

## Що ми вже вивчили?

1)	В першу чергу нам необхідно описати тривимірні об'єкти за допомогою таких речей, як вершини і топології (інформація про те, як ці вершини з'єднані одна з одною з утворенням багатокутника або особи), перш ніж ми можемо отримати зображення 3D сцени (сцена - зібрання об'єктів).

2)	Візуалізація (рендеринг) - це процес, за допомогою якого створюється зображення 3D сцени. Незалежно від того, який метод використовується для створення 3D-моделі (їх досить багато), рендеринг є необхідним кроком на шляху щоб «побачити» будь-який віртуальний 3D світ.

3)	З цієї простої вправи повинно бути абсолютно очевидно, що математика (більш ніж програмування) відіграють важливу роль в процесі створення зображення за допомогою комп'ютера. Насправді комп'ютер є лише інструментом, який використовується для прискорення обчислень, але правила, що використовуються для створення цього зображення - це чиста математика. Геометрія грає особливо важливу роль в цьому процесі, зокрема, для роботи з об'єктами перетворення (масштаб, поворот, переміщення), і також для забезпечення вирішення таких проблем, як обчислення кутів між лініями, або з'ясування перетин між лінією і іншими простими об'єктами (площина, сфера і т.д.).

4)	Як висновок, комп'ютерна графіка це в основному математика застосована в комп'ютерній програмі, метою якої є для створення зображення (фото-реалістичні чи ні) з найшвидшою можливою швидкістю (і з точностю, на яку комп'ютери здатні).

5)	Моделювання включає в себе всі техніки, використовувані для створення 3D-моделей. Методи моделювання будуть розглянуті в розділах Геометрія / Моделювання.

6)	У той час як статичні моделі гарні, але їх також можна оживити протягом певного часу. Це означає, що зображення моделі на кожному часовому кроці може бути відрендерене (можна, наприклад, перемістити, обертати або масштабувати коробку потрохи на кожному наступному зображенні чи анімувати координати кутів або застосовувати матрицю перетворення моделі). Більш просунуті технології анімації можуть бути використані для імітації деформації шкіри на кістках і м'язах. Але всі ці методи мають в загальному ту ж геометрію (грані стають моделями), що деформувалася з часом. Тому час, як це було запропоновано у вступі важливий в CGI також. Перевірте розділ анімації, щоб дізнатися про цю тему.

7)	Одне конкретне поле перекриває як анімацію так і моделювання. Воно включає в себе всі методи, використовувані для моделювання руху об'єктів в реалістичній манері. Дуже велика галузь комп'ютерної графіки присвячена моделюванню руху рідини (вода, вогонь, дим), тканини, волосся і т.д. Закони фізики застосовуються до 3D-моделі, щоб змусити їх рухатися, деформуватися або ламатися, як це є в реальному світі. Фізика моделювання, як правило, потребує дуже великих обчислювальних витрат, але вони також можуть працювати в режимі реального часу (все залежить від складності сцени, яку ви симулюєте).

8)	Рендеринг також обчислювально затратне завдання. Як затратно залежить від того, наскільки багато геометрії вкладено у вашу сцену і наскільки фото-реалістичне ви хочете остаточне зображення. У рендерингу, ми розрізняємо два режими, офлайн режим і режим реального часу рендерингу. У режимі реального часу використовується (насправді це вимога) для відеоігор, в яких контент 3D-сцен повинен бути відрендерений (візуалізований) щонайменше 30 кадрів в секунду (як правило, 60 кадрів в секунду, вважається стандарт). Більшість рендерингу в реальному часі виконується на GPU - процесор, який спеціально розроблений для візуалізації 3D сцен на максимально можливій швидкості. Методи візуалізації в реальному часі будуть обговорюватися в розділі Realtime. Offline рендеринг зазвичай використовується у виробництві CGI для фільмів, де в режим реального часу не є обов'язковою вимогою (зображення попередньо обчислюється і зберігається перед відображенням на 24 або 30 або 60 кадрів в секунду). Це може зайняти від декількох секунд до декількох годин, перш ніж одине єдине зображення буде завершене, але воно зазвичай обробляє набагато більше геометрії і створює зображення більш високої якості, ніж рендеринг в реальному часі. Проте, режим реального часу та офлайн режим рендеринга мають тенденцію перекривати один одного все більше і більше в ці дні, у відео-іграх збільшується кількість геометрії, яку вони можуть обробляти в хорошій якості, а тому офлайн двигуни рендерингу намагаються скористатися останніми досягненнями в області технологій CPU, щоб значно поліпшити свої характеристки. Офф-лайн рендеринг є головною темою кількох розділів на Scratchapixel: Основи 3D-рендеринга, методи, специфічні для трасування променів, легкі транспортні алгоритмів, затінення і процедурне текстурування. Ми радимо вам прочитати уроки першого розділу в хронологічному порядку.

## Де я повинен починати?

Ми сподіваємося, що простий приклад з коробкою зачепив тебе, але головна мета цього введення є, щоб підкреслити ту роль, яку відіграє геометрія в комп'ютерній графіці. Звичайно, це не тільки про геометрію, але багато проблем може бути вирішено за допомогою геометрії. Більшість книг з комп'ютерної графіки починаються з главою про геометрію, яка завжди трохи лякає, тому що здається, що вам потрібно багато вчитися, перш ніж ви зможете робити прикольні речі. Тим не менш, ми дійсно рекомендуємо вам прочитати урок по геометрії, перш ніж що-небудь починати. Ми будемо говорити і дізнаємося про точки, і про поняття вектора і нормаль. Ми дізнаємося про системи координат і, що більш важливо про поняття матриці. Матриці широко використовуються для обробки перетворень, таких як обертання, масштабування або зміщення. Ці поняття використовуються повсюдно у всій літературі про комп'ютерну графіку, тому вам необхідно вивчити їх першими.

Багато книг про CG не забезпечують гарне введення до геометрії, можливо, тому що автори припускають, що читачі вже знають про це або, що краще читати книги, присвячені цій конкретній темі. Наш урок по геометрії дуже різноманітний. Він дуже ретельний і пояснює все в дуже простих словах (в тому числі і те, про що вам розкажуть тільки люди прошарені в цій темі). Почни з читання цього уроку.

## Що я повинен читати далі? 
Це зазвичай простіше і веселіше, щоб почати навчатись програмування комп'ютерної графіки з рендерингу. Один з можливих способів для вас, щоб пройти через зміст цього сайту, щоб почати читати уроки з розділу Основи 3D Рендерингу в хронологічному порядку. Для того, щоб зрозуміти зміст уроку вам можуть знадобитися попередні знання про деякі інші методи. На початку кожного уроку ви знайдете список інших уроків, який містить все, що потрібно знати для того, щоб зрозуміти зміст уроку, який ви збираєтеся почати (ми називаємо їх передумова). Використовуйте цей список, щоб направляти вас через вміст веб-сайту і що ще більш важливо отримати основи, необхідні для того, щоб прогресувати в навчанні.
